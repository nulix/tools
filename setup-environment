# vim: set ft=sh:
set -o pipefail

RED="\\e[31m"
YELLOW="\\e[33m"
BLUE="\\e[34m"
WHITE="\\e[37m"
NC="\\e[0m"
THIS_DIR="$(pwd)"

LOG_ERR() {
  echo -e "${RED}ERROR:${NC} ${@}"
}

LOG_WRN() {
  echo -e "${YELLOW}WARNING:${NC} ${@}"
}

LOG_INF() {
  echo -e "${BLUE}INFO:${NC} ${@}"
}

LOG_DBG() {
  echo -e "${WHITE}DEBUG:${NC} ${@}"
}

###
### Function to build BSP
###
build_bsp() {
  LOG_INF "Starting $MACHINE BSP build..."

  cd ${THIS_DIR}/bsp

  docker build -f Dockerfile.$MACHINE . -o . \
    --build-arg MACHINE="$MACHINE" \
    --build-arg ARCH="$MACHINE_ARCH" \
    --build-arg UBOOT_REPO="$UBOOT_REPO" \
    --build-arg UBOOT_BRANCH="$UBOOT_BRANCH" \
    --build-arg UBOOT_DEFCONFIG="$UBOOT_DEFCONFIG" \
    --build-arg KERNEL_REPO="$KERNEL_REPO" \
    --build-arg KERNEL_BRANCH="$KERNEL_BRANCH" \
    --build-arg KERNEL_DEFCONFIG="$KERNEL_DEFCONFIG" \
    --build-arg KERNEL_IMAGE="$KERNEL_IMAGE" \
    || return

  rm -f ../build/deploy/$MACHINE/boot-artifacts-*.tar.gz \
    ../build/deploy/$MACHINE/kernel-artifacts-*.tar.gz \
    ../build/deploy/$MACHINE/kernel-modules-*.tar.gz
  mv boot-artifacts-*.tar.gz ../build/deploy/$MACHINE
  mv kernel-artifacts-*.tar.gz ../build/deploy/$MACHINE
  mv kernel-modules-*.tar.gz ../build/deploy/$MACHINE
  cd ${THIS_DIR}

  # TODO: make this better?
  cp build/deploy/$MACHINE/kernel-artifacts-*.tar.gz rootfs/machine/$MACHINE
  cp build/deploy/$MACHINE/kernel-modules-*.tar.gz rootfs/machine/$MACHINE

  LOG_INF "BSP built!"
}

###
### Function to build rootfs tar.gz
###
build_rootfs() {
  LOG_INF "Starting $MACHINE rootfs build..."

  cd ${THIS_DIR}/rootfs
  rm -f nulix-rootfs-*.tar.gz

  docker build -o - . \
    --build-arg MACHINE="$MACHINE" \
    --build-arg HOSTNAME="$HOSTNAME" \
    --build-arg KERNEL_IMAGE="$KERNEL_IMAGE" \
    --build-arg VIRT_BACKEND="$VIRT_BACKEND" \
    --build-arg SERIAL_PORT="$SERIAL_PORT" \
    --build-arg SERIAL_BAUD="$SERIAL_BAUD" \
    --build-arg DISTRO_VERSION_MAJOR="$DISTRO_VERSION_MAJOR" \
    --build-arg DISTRO_VERSION_MINOR="$DISTRO_VERSION_MINOR" \
    --build-arg DISTRO_VERSION_PATCH="$DISTRO_VERSION_PATCH" \
    | gzip > nulix-rootfs-$DISTRO_VERSION_MAJOR.$DISTRO_VERSION_MINOR.$DISTRO_VERSION_PATCH.tar.gz \
    || return

  rm -f ../build/deploy/$MACHINE/nulix-rootfs-*.tar.gz
  # TODO: rootfs image is needed in this dir for the ostree_repo build,
  # try to use it from the build dir instead
  cp nulix-rootfs-*.tar.gz ../build/deploy/$MACHINE
  cd ${THIS_DIR}

  LOG_INF "Root filesystem built!"
}

###
### Function to build rootfs docker image, useful for testing:
###  $ docker run --rm -it nulix-rootfs:1.0.0
###
build_rootfs_docker_image() {
  LOG_INF "Starting $MACHINE rootfs docker image build..."

  cd ${THIS_DIR}/rootfs

  docker build . \
    --build-arg MACHINE="$MACHINE" \
    --build-arg HOSTNAME="$HOSTNAME" \
    --build-arg KERNEL_IMAGE="$KERNEL_IMAGE" \
    --build-arg VIRT_BACKEND="$VIRT_BACKEND" \
    --build-arg SERIAL_PORT="$SERIAL_PORT" \
    --build-arg SERIAL_BAUD="$SERIAL_BAUD" \
    --build-arg DISTRO_VERSION_MAJOR="$DISTRO_VERSION_MAJOR" \
    --build-arg DISTRO_VERSION_MINOR="$DISTRO_VERSION_MINOR" \
    --build-arg DISTRO_VERSION_PATCH="$DISTRO_VERSION_PATCH" \
    -t nulix-rootfs:$DISTRO_VERSION_MAJOR.$DISTRO_VERSION_MINOR.$DISTRO_VERSION_PATCH \
    || return

  cd ${THIS_DIR}

  LOG_INF "Root filesystem docker image built!"
}

###
### Function to build OSTree repo
###
build_ostree_repo() {
  LOG_INF "Starting $MACHINE OSTree repo build..."

  cd ${THIS_DIR}/rootfs

  docker build -f Dockerfile.ostree_repo . -o . \
    --build-arg MACHINE="$MACHINE" \
    --build-arg DISTRO_VERSION_MAJOR="$DISTRO_VERSION_MAJOR" \
    --build-arg DISTRO_VERSION_MINOR="$DISTRO_VERSION_MINOR" \
    --build-arg DISTRO_VERSION_PATCH="$DISTRO_VERSION_PATCH" \
    --build-arg OSTREE_REPO="$OSTREE_REPO" \
    --build-arg OSTREE_MANIFEST="$OSTREE_MANIFEST" \
    --build-arg OSTREE_ROOTFS="$OSTREE_ROOTFS" \
    --build-arg OSTREE_UPDATE_SUMMARY="$OSTREE_SUMMARY" \
    || return

  # TODO: the $OSTREE_REPO dir is needed for next build to keep
  # the commit history, try to use it from the build dir instead
  rm -rf ../build/deploy/$MACHINE/$OSTREE_REPO \
    ../build/deploy/$MACHINE/$OSTREE_MANIFEST \
    ../build/deploy/$MACHINE/$OSTREE_REPO.tar.gz
  cp -r $OSTREE_REPO ../build/deploy/$MACHINE
  mv $OSTREE_REPO.tar.gz $OSTREE_MANIFEST ../build/deploy/$MACHINE
  cd ${THIS_DIR}

  LOG_INF "OSTree repo built!"
}

###
### Function to create bootable disk image
###
mk_image() {
  if [ ! -d "${THIS_DIR}/build/deploy/$MACHINE" ]; then
    LOG_ERR "deploy directory not found, can't proceed!"
    return -1
  fi

  LOG_INF "Starting $MACHINE disk image build..."


  cd ${THIS_DIR}/build/deploy/$MACHINE
  rm -f Dockerfile.disk-image \
    nulix-os*.img.bz2
  cp ${THIS_DIR}/tools/Dockerfile.disk-image .

  docker build -f Dockerfile.disk-image . -o . \
    --build-arg MACHINE="$MACHINE" \
    --build-arg DISTRO_VERSION_MAJOR="$DISTRO_VERSION_MAJOR" \
    --build-arg DISTRO_VERSION_MINOR="$DISTRO_VERSION_MINOR" \
    --build-arg DISTRO_VERSION_PATCH="$DISTRO_VERSION_PATCH" \
    --build-arg OSTREE_REPO="$OSTREE_REPO" \
    --build-arg OSTREE_MANIFEST="$OSTREE_MANIFEST" \
    --build-arg OTA_SYSROOT="$OSTREE_OTA_SYSROOT" \
    --build-arg OSTREE_OSNAME="$OSTREE_OSNAME" \
    || return

  rm Dockerfile.disk-image
  cd ${THIS_DIR}

  LOG_INF "Bootable disk image built!"
}

###
### Function to clean docker build cache and build directory
###
clean_all() {
  rm -rf ${THIS_DIR}/build/conf \
    ${THIS_DIR}/build/deploy/$MACHINE \
    ${THIS_DIR}/rootfs/$OSTREE_REPO \
    ${THIS_DIR}/rootfs/$OSTREE_MANIFES

  # TODO: use dedicated docker build context!
  docker builder prune -af || return

  LOG_INF "Project for $MACHINE cleaned!"
}

###
### Print general usage
###
usage() {
  echo "Usage: nulix {build|clean-all}"
}

###
### Print usage for build sub-command
###
usage_build() {
  echo "Usage: nulix build {bsp|rootfs|rootfs-docker-image|ostree-repo|os}"
}

###
### Check dependencies
###
init() {
  if ! which docker &> /dev/null; then
    LOG_ERR "docker is not installed!"
    return -1
  fi

  if ! which yq &> /dev/null; then
    LOG_DBG "yq is not installed, will use internal wrapper..."
    alias yq='_yq'
  fi

  if [ ! -d "$THIS_DIR/bsp" ]; then
    LOG_ERR "bsp source directory not found!"
    return -1
  fi

  if [ ! -d "$THIS_DIR/rootfs" ]; then
    LOG_ERR "rootfs source directory not found!"
    return -1
  fi

  if [ ! -d "$THIS_DIR/tools" ]; then
    LOG_ERR "tools source directory not found!"
    return -1
  fi

  # set machine
  DEFAULT_MACHINE="rpi3"
  if [ -z "$MACHINE" ]; then
    MACHINE="$DEFAULT_MACHINE"
  fi

  if [ ! -f "$THIS_DIR/tools/machine/$MACHINE.yaml" ]; then
    LOG_WRN "machine file not found for $MACHINE, defaulting to $DEFAULT_MACHINE"
    MACHINE="$DEFAULT_MACHINE"
  fi

  # set distro
  DEFAULT_DISTRO="nulix-docker"
  if [ -z "$DISTRO" ]; then
    DISTRO="$DEFAULT_DISTRO"
  fi

  if [ ! -f "$THIS_DIR/tools/distro/$DISTRO.yaml" ]; then
    LOG_WRN "distro file not found for $DISTRO, defaulting to $DEFAULT_DISTRO"
    DISTRO="$DEFAULT_DISTRO"
  fi

  LOG_INF "MACHINE=$MACHINE"
  LOG_INF "DISTRO=$DISTRO"

  # init build directory
  mkdir -p "$THIS_DIR/build"
  mkdir -p "$THIS_DIR/build/conf"
  mkdir -p "$THIS_DIR/build/deploy"
  mkdir -p "$THIS_DIR/build/deploy/$MACHINE"
  rm -f "$THIS_DIR/build/conf/local.conf"
}

###
### yq wrapper function
###
_yq() {
  docker run --rm -v "${THIS_DIR}":/workdir mikefarah/yq -e "$@"
}

###
### Set parsed config to local file
###
set_conf() {
  LOG_DBG "$@"
  echo "$@" >> "$THIS_DIR/build/conf/local.conf"
}

###
### Set machine settings
###
parse_machine() {
  MACHINE_FILE="tools/machine/$MACHINE.yaml"

  # read values from $MACHINE_FILE
  MACHINE=$(yq ".machine.name" $MACHINE_FILE) || return
  MACHINE_ARCH=$(yq ".machine.arch" $MACHINE_FILE) || return
  MACHINE_OWNER=$(yq ".machine.owner" $MACHINE_FILE) || return
  HOSTNAME=$(yq ".machine.hostname" $MACHINE_FILE) || return
  UBOOT_REPO=$(yq ".machine.uboot.repo" $MACHINE_FILE) || return
  UBOOT_BRANCH=$(yq ".machine.uboot.branch" $MACHINE_FILE) || return
  UBOOT_DEFCONFIG=$(yq ".machine.uboot.defconfig" $MACHINE_FILE) || return
  KERNEL_REPO=$(yq ".machine.kernel.repo" $MACHINE_FILE) || return
  KERNEL_BRANCH=$(yq ".machine.kernel.branch" $MACHINE_FILE) || return
  KERNEL_DEFCONFIG=$(yq ".machine.kernel.defconfig" $MACHINE_FILE) || return
  KERNEL_IMAGE=$(yq ".machine.kernel.image" $MACHINE_FILE) || return
  SERIAL_PORT=$(yq ".machine.serial.port" $MACHINE_FILE) || return
  SERIAL_BAUD=$(yq ".machine.serial.baud" $MACHINE_FILE) || return

  set_conf "MACHINE=$MACHINE"
  set_conf "MACHINE_ARCH=$MACHINE_ARCH"
  set_conf "MACHINE_OWNER=$MACHINE_OWNER"
  set_conf "HOSTNAME=$HOSTNAME"
  set_conf "UBOOT_REPO=$UBOOT_REPO"
  set_conf "UBOOT_BRANCH=$UBOOT_BRANCH"
  set_conf "UBOOT_DEFCONFIG=$UBOOT_DEFCONFIG"
  set_conf "KERNEL_REPO=$KERNEL_REPO"
  set_conf "KERNEL_BRANCH=$KERNEL_BRANCH"
  set_conf "KERNEL_DEFCONFIG=$KERNEL_DEFCONFIG"
  set_conf "KERNEL_IMAGE=$KERNEL_IMAGE"
  set_conf "SERIAL_PORT=$SERIAL_PORT"
  set_conf "SERIAL_BAUD=$SERIAL_BAUD"
}

###
### Set distro settings
###
parse_distro() {
  DISTRO_FILE="tools/distro/$DISTRO.yaml"

  # read values from $DISTRO_FILE
  ROOTFS_BASE=$(yq ".distro.rootfs" $DISTRO_FILE) || return
  VIRT_BACKEND=$(yq ".distro.virt.backend" $DISTRO_FILE) || return
  OSTREE_REPO=$(yq ".distro.ostree.repo" $DISTRO_FILE) || return
  OSTREE_MANIFEST=$(yq ".distro.ostree.manifest" $DISTRO_FILE) || return
  OSTREE_ROOTFS=$(yq ".distro.ostree.rootfs" $DISTRO_FILE) || return
  OSTREE_SUMMARY=$(yq ".distro.ostree.summary" $DISTRO_FILE) || return
  OSTREE_OTA_SYSROOT=$(yq ".distro.ostree.ota-sysroot" $DISTRO_FILE) || return
  OSTREE_OSNAME=$(yq ".distro.ostree.os-name" $DISTRO_FILE) || return
  DISTRO_VERSION_MAJOR=$(yq ".distro.version.major" $DISTRO_FILE) || return
  DISTRO_VERSION_MINOR=$(yq ".distro.version.minor" $DISTRO_FILE) || return
  DISTRO_VERSION_PATCH=$(yq ".distro.version.patch" $DISTRO_FILE) || return

  set_conf "ROOTFS_BASE=$ROOTFS_BASE"
  set_conf "VIRT_BACKEND=$VIRT_BACKEND"
  set_conf "OSTREE_REPO=$OSTREE_REPO"
  set_conf "OSTREE_MANIFEST=$OSTREE_MANIFEST"
  set_conf "OSTREE_ROOTFS=$OSTREE_ROOTFS"
  set_conf "OSTREE_SUMMARY=$OSTREE_SUMMARY"
  set_conf "OSTREE_OTA_SYSROOT=$OSTREE_OTA_SYSROOT"
  set_conf "OSTREE_OSNAME=$OSTREE_OSNAME"
  set_conf "DISTRO_VERSION_MAJOR=$DISTRO_VERSION_MAJOR"
  set_conf "DISTRO_VERSION_MINOR=$DISTRO_VERSION_MINOR"
  set_conf "DISTRO_VERSION_PATCH=$DISTRO_VERSION_PATCH"
}

init || return -1
parse_machine || return -1
parse_distro || return -1

###
### Main command handler
###
nulix() {
  local cmd="$1"
  shift # remove the top-level command

  case "$cmd" in
    build)
      for subcmd in "$@"; do
        case "$subcmd" in
          bsp) build_bsp ;;
          rootfs) build_rootfs ;;
          rootfs-docker-image) build_rootfs_docker_image ;;
          ostree-repo) 
            build_bsp && build_rootfs && build_ostree_repo ;;
          os) 
            build_bsp && build_rootfs && build_ostree_repo && mk_image ;;
          help) usage_build; return 0 ;;
          *) 
            LOG_ERR "Unknown build target: $subcmd"
            usage_build
            return 1
            ;;
        esac
      done
      ;;
    clean-all)
      clean_all
      ;;
    help)
      usage
      return 0
      ;;
    *)
      LOG_ERR "Unknown command: $cmd"
      usage
      return 1
      ;;
  esac
}

